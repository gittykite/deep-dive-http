# 3장 HTTP 메시지

HTTP 완벽 가이드 책을 읽고 이해한 내용을 정리한 글입니다.

---

이번 장에서는 좀 더 구체적으로 아래와 같은 내용에 대해서 배울 수 있습니다.
- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들입니다. 이 메시지는 클라이언트, 서버, 프락시 사이를 흐릅니다. '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어입니다.

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용합니다. 메시지가 원 서버로 가는 것은 인바운드로 이동하는 것이고, 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것입니다.

### 3.1.2 다운스트림으로 흐르는 메시지

모든 메시지는 다운 스트림으로 흐릅니다. 메시지의 발송자는 곧 수신자의 업스트림입니다.

## 3.2 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록입니다. 메시지는 시작줄, 헤더 블록, 본문 세 부분으로 나뉘고 시작줄은 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있고 있을 수도 없을 수도 있습니다.

```시작 줄```과 ```헤더```는 줄 단위로 분리된 아스키 문자열이고, 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열인 'CRLF'으로 끝납니다.
엔티티 본문이나 메시지 본문은 시작줄이나 헤더와는 달리, 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있습니다.

```Content-type```은 본문이 어떤 타입인지 ```Content-Length``는 본문의 크기를 보여줍니다.

### 3.2.1 메시지 문법

**요청 메시지**

웹 서버에 동작을 요구하는 메시지로 요청과 응답은 기본적으로 구조가 같습니다.
```
<메시지> <요청URL> <버전>
<헤더>

<엔티티 본문>
```
**응답 메시지**

응답 메시지는 시작줄에서만 문법이 다르고, 요청의 결과를 클라이언트에게 돌려줍니다.
```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔티티 본문>
```

**메서드**

리소스에 대해 수행해주길 바라는 동작으로 ```GET```, ```HEAD```, ```POST``와 같이 한 단어로 되어있습니다.

**요청 URL**

요청 대상이 되는 리소스를 지칭하는 URL 혹은 URL의 경로 구성요소입니다. 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주합니다.

**버전**

메시지에서 사용 중인 HTTP 버전입니다. 형식은 메이저, 마이너 모두 정수인 ```HTTP/<메이저>.<마이너>``` 형식입니다.

**상태 코드**

요청 중에 무엇이 일어났는지 설명해주는 세 자리의 숫자입니다. 코드의 첫 번째 숫자는 성공, 에러 등을 나타냅니다.

**사유 구절(reason-phrase)**

상태 코드 이후 줄바꿈 문자열까지의 구절로 상태 코드의 의미를 이해할 수 있게 설명해주는 문구입니다. 예를 들면 ```HTTP/1.0 200 NOT OK, HTTP/1.0 200 OK```는 동등하게 성공을 의미하는 것으로 처리됩니다.

**헤더**

HTTP/1.1 과 같은 몇몇 버전의 HTTP 요청이나 응답에 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주됩니다.

**엔티티 본문**

모든 메시지가 엔티티 본문을 가지는건 아니므로, 메시지는 때때로 CRLF 로 끝나게 됩니다.

헤더나 엔티티 본문이 없더라도 HTTP 헤더의 집합은 항상 CRLF 로 끝나야 합니다. 그러나 규칙을 잘 지키지 않은 구현체와의 호환을 위해 클라이언트와 서버는 마지막 CRLF 없이 끝나는 메시지도 받아들일 수 있어야 합니다.

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작합니다.

**요청줄**

요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 있습니다. 또한 요청줄은 클라이언트가 어떤 HTTP버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함합니다.

**응답줄**

응답줄은 응답 메시지에서 쓰인 HTTP 버전, 숫자로 된 상태코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 있습니다.

**메서드**

요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해줍니다.

### 3.2.3 헤더

HTTP 헤더 필드는 요청과 응답 메시지에 기본적으로 이름/값 쌍의 목록으로 추가 정보를 더합니다.

**헤더 분류**

HTTP 헤더는 아래와 같이 분류 됩니다.

-  일반 헤더
    - 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더
    - 요청에 대한 부가 정보를 제공
- 응답 헤더
    - 응답에 대한 부가 정보 제공
- Entity 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더
    - 명세에 정의되지 않은 새로운 헤더


| 헤더의 예 | 설명 |
|---|:---:|
| `Date: Tue, 3 Oct 2020 02:16:03 GMT` | 서버가 응답을 만들어 낸 시각 |
| `Content-length: 15040` | 15,040 바이트의 데이터를 포함한 엔티티 본문 |
| `Content-type: image/gif` | 엔티티 본문은 GIF 이미지 |
| `Accept: image/gif, image/jpeg, text/html` | 클라이언트는 GIF, JPEG 이미지와 HTML 을 받아들일 수 있다. |

**헤더를 여러 줄로 나누기**

헤더가 길어지는 경우에는 줄 앞에 최소 하나의 스페이스 혹은 탭 문자를 입력하면 헤더를 여러 줄로 나눌 수 있습니다.

예)
```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Sever: Test Server
    Version: 1.0
```

### 3.2.4 엔티티 본문

HTTP 메시지의 엔티티 본문은 다양한 컨텐츠를 실어 나를 수 있습니다.

### 3.2.5 버전 0.9 메시지

HTTP/0.9 메시지는 요청과 응답으로 이루어져 있지만, 요청은 요청 메서드와 요청 URL 을 가지고 있으며 응답 메서드는 단지 엔티티만으로 이루어져 있습니다. 버전 정보, 사유 구절, 상태 코드가 없으며 헤더도 포함되어 있지 않습니다.

## 3.3. 메서드

몇몇 기본적인 HTTP 메서드에 대해서 알아보려고 합니다. 모든 서버가 모든 메서드를 구현하지는 않는다는 것에 주의해야 합니다.

### 3.3.1 안전한 메서드

### 3.3.2 GET

서버에게 리소스를 요청하기 위해 쓰이는 메서드로 HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구합니다.

### 3.3.3 HEAD

GET 메서드와 동일하게 동작하지만, 서버는 응답으로 헤더만을 돌려주고 엔티티 본문은 돌려주지 않습니다.
- 리소스를 가져오지 않고도 그에 대해 타입이나 다른 것을 알 수 있습니다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있습니다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있습니다.

### 3.3.4 PUT

PUT 메서드는 서버에 문서를 작성합니다. 요청의 본문으로 요청 URL의 이름대로 새 문서를 생성하거나, 이미 URL 이 존재한다면 본문을 사용해서 수정할 수 있습니다.
PUT 메서드는 컨텐츠를 변경할 수 있기 때문에, 많은 웹 서버는 PUT을 수행하기 전에 인증을 요구할 것입니다.

### 3.3.5 POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었습니다. 데이터는 서버로 전송되며 서버는 이를 필요로 하는 곳에 보냅니다.

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있습니다. ```TRACE```메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줍니다.

TRACE 메서드는 주로 진단을 위해 사용됩니다. 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있고, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구입니다.


### 3.3.7 OPTIONS

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있는 메서드로 여러 리소스에 대해 실제 접근하지 않고도 어떻게 접근할 수 있는지에 대한 수단을 클라이언트 애플리케이션에게 제공합니다.

### 3.3.8 DELETE

DELETE 메서드는 서버에게 요청 URL 로 지정한 리소스를 삭제할 것을 요청합니다. HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문에 삭제가 된 부분에 대해서는 보장할 수 없습니다.

### 3.3.9 확장 메서드

개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공합니다. 필요에 따라 확장해도 문제가 없도록 설계가 되어있으므로, 새로 기능을 추가해도 기존 스펙에 대해서는 오동작을 유발하지 않습니다.

## 3.4 상태 코드

상태 코드는 클라이언트에게 트랜잭션을 이해할 수 있는 쉬운 방법을 제공해줍니다.

### 3.4.1 100-199: 정보성 상태 코드

| 상태 코드 | 사유 구절 | 의미 |
|---|:---:|:---:|
| `100` | Continue | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미 |
| `101` | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꿨음을 의미 |

**클라이언트는 100-Continue** 를 서버가 다루거나 사용할 수 없는 큰 엔티티를 서버에게 보내지 않으려는 목적으로만 사용해야 합니다.


### 3.4.2 200-299: 성공 상태 코드

클라이언트가 요청을 보냈을 때, 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응해야 합니다.

| 코드 | 사유 구절 | 의미 |
|---|:---:|:---:|
| `200` | OK | 요청 정상, 엔티티 본문은 요청된 리소스를 포함 |
| `201` | Created | 객체를 생성하고 서버가 보내는 상태 코드, 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 리소스를 참조할 수 있는 여러 URL을 포함 |
| `202` | Accepted | 요청은 받아들여졌으나 어떤 동작을 수행하지 않았을 때, 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료 될 것인지에 대한 추정도 포함해야 함 |
| `203` | Non-Authoritative Information | 엔티티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔을 때, 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 헤더를 검증하지 못한 경우 발생 |
| `204` | No Content | 헤더와 상태줄을 포함하지만 엔티티 본문은 포함하지 않았을 때, 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용 |
| `205` | Reset Content | 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 값을 비우라고 할 때 |
| `206` | Partial Content | 부분 요청이 성공했을 때, Content-Range 와 Date 헤더를 반드시 포함해야 하며, Etag 와 Content-Location 중 하나의 헤더도 반드시 포함해야 함 |

### 3.4.3 300-399: 리다이렉션 상태 코드

클라이언트가 요청한 리소스에 대해 다른 위치를 사용하라고 말해주거나 리소스의 내용 대신 다른 응답을 제공하기 위해 리다이렉션 상태 코드와 Location 헤더를 보낼 수 있습니다.

일반적으로 HEAD 가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트 될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관입니다.

아래의 표는 리다이렉션 상태 코드를 나열하고 있습니다. 

| 코드 | 사유 구절 | 의미 |
|---|:---:|:---:|
| `300` | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청하였을 경우, 그 리소스의 목록과 함께 반환 |
| `301` | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용, 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함 |
| `302` | Found | 클라이언트는 Location 헤더로 주어진 URL을 임시로 가리키기 위한 목적으로 사용되고 이후에는 원래 URL을 사용해야 함 |
| `303` | See Other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말할 때 사용, 새 URL은 응답 메시지의 Location 에 존재 |
| `304` | Not Modified | 헤더를 이용해 조건부 요청을 만들 수 있음. 클라이언트가 GET과 같은 조건부 요청을 보내고, 요청한 리소스가 수정된 일이 없다면 리소스가 수정되지 않았음을 의미, 엔티티 본문 X |
| `305` | Use Proxy | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위한 상태 코드 |
| `307` | Temporary Redirect | Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용 |

```302, 303, 307``` 상태 코드의 차이점은 아래와 같습니다.

- 상태 코드 302 : HTTP/1.0 클라이언트가 POST 요청을 보내고 302 응답을 받으면, 클라이언트는 Location 헤더에 있는 URL 을 GET 요청을 합니다.

- 상태 코드 303 : HTTP/1.1 명세는 이러한 리다이렉션을 위해 303 상태 코드를 사용하였다.

- 상태 코드 307 : HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 상태 코드 대신 307 상태 코드를 사용하게끔 하고, 302 상태코드는 HTTP/1.0 클라이언트에게 사용하기 위해 남겨두었습니다.

### 3.4.4 400-499 : 클라이언트 에러 상태 코드

존재하지 않는 URL에 대한 요청을 보내거나 잘못 구성된 요청 메시지를 보내면 다양한 클라이언트 에러 상태 코드를 보냅니다.

| 코드 | 사유 구절 | 의미 |
|---|:---:|:---:|
| `400` | Bad Request | 클라이언트가 잘못된 요청을 보냈을 때 |
| `401` | Unauthorized | 리소스를 얻기 전에 클라이언트에게 인증을 요구하는 상태 코드 |
| `402` | Payment Required | 현재 상태 코드가 쓰이지 않음 |
| `403` | Forbidden | 요청이 서버에 의해 거부되었음을 알려주기 위해 사용함. 거부되었는지 엔티티 본문에 이유를 포함시킬 수 있음 |
| `404` | Not Found | 서버가 요청한 URL을 찾을 수 없을 때 사용 |
| `405` | Method Not Allowed | 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용. Allow 헤더에 어떤 메서드가 사용 가능한지 포함 |
| `406` | Not Acceptable | 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용 |
| `407` | Proxy Authentication Required | 401 상태 코드와 같으나, 리소스에 대한 인증을 요구하는 프락시 서버를 위해 사용 |
| `408` | Request Timeout | 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 이 상태 코드로 응답하고 연결을 끊을 수 있음 |
| `409` | Conflict | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용 |
| `410` | Gone | 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었따는 점이 다르고 웹사이트를 유지보수하면서 서버 관리자가 클라이언트에게 리소스가 제거 됐을 때 알려주기 위해 사용 |
| `411` | Length Required | 요청 메시지에 Content-Length 헤더가 있을 것을 요구 |
| `412` | Precondition Failed | 클라이언트가 조건부 요청을 했는데 하나가 실패했을 때 사용, 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생 |
| `413` | Request Entity Too Large | 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용 |
| `414` | Request URI Too Long | 처리하고자 하는 한계를 넘은 크기의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용 |
| `415` | Unsupported Media Type | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔티티를 클라이언트가 보냈을 때 사용 |
| `416` | Requested Range Not Satisfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 |
| `417` | Expectation Failed | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용 |

### 3.4.5 500-599 : 서버 에러 상태 코드

클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있습니다. 서버의 제한에 걸린 것일수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있습니다.

| 코드 | 사유 구절 | 의미 |
|---|:---:|:---:|
| `500` | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 |
| `501` | Not Implemented | 클라이언트가 서버의 능력을 넘은 요청을 했을 때 |
| `502` | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용 |
| `503` | Service Unavailable | 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때 사용 |
| `504` | Gateway Timeout | 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다름 |
| `505` | HTTP Version Not Supported | 서버가 지원할 수 없는 버전의 프로토콜로 된 요청을 받았을 때 사용 |

## 3.5 헤더

헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 일반 목적에 사용하는 헤더, 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있습니다.

### 3.5.1 일반 헤더

- 클라이언트와 헤더 양쪽 모두 사용
- 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용 됩니다.
- 예) Date 헤더는 서버와 클라이언트를 가리지 않고 메시지가 만들어진 일시를 지칭하기 위해 사용하는 헤더

| 헤더 | 설명 |
|---|:---:|
| `Connection` | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 함 |
| `Date` | 메시지 생성의 날짜 시간 |
| `MIME-Version` | 발송자가 사용한 MIME의 버전 |
| `Trailer chunked transfer` | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열 |
| `Transfer-Encoding` | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 알려줌 |
| `Upgrade` | 발송자가 '업그레이드' 하길 원하는 새 버전이나 프로토콜을 알려줌 |
| `Via` | 이 메시지가 어떤 중개자를 거쳐 왔는지 보여줌 |

- **일반 캐시 헤더**는 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했습니다. ```Cache-Control```은 메시지와 함께 캐시 지시자를 전달하기 위해 사용, ```Pragma```는 메시지와 함께 지시자를 전달하는 또 다른 방법, 캐시에 국한되지 않음

### 3.5.2 요청 헤더

- 요청 메시지를 위한 헤더로 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공
- 예) ```Accept: */*```Accept 헤더는 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미

| 헤더 | 설명 |
|---|:---:|
| `Client-IP` | 클라이언트가 실행된 컴퓨터의 IP |
| `From` | 클라이언트 사용자의 메일 주소 |
| `Host` | 요청의 대상이 되는 서버의 호스트 명과 포트 |
| `Referer` | 현재의 요청 URI가 들어있었던 문서의 URL을 제공 |
| `UA-Color` | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보 |
| `UA-CPU` | 클라이언트 CPU의 종류나 제조사 |
| `UA-Disp` | 클라이언트 디스플레이 능력에 대한 정보 |
| `UA-OS` | 클라이언트 기기에서 동작 중인 운영체제의 이름과 버전 |
| `UA-Pixels` | 클라이언트 기기 디스플레이에 대한 픽셀 정보 |
| `User-Agent` | 요청을 보낸 애플리케이션 이름 |

**Accept 관련 헤더**

클라이언트는 Accept 관련 헤더를 이용해 서버에게 무엇을 원하고 무엇을 할 수 있는지, 무엇을 원치 않는지 알려줄 수 있습니다.

| 헤더 | 설명 |
|---|:---:|
| `Accept` | 서버가 보내도 되는 미디어 종류 |
| `Accept-Charset` | 서버가 보내도 되는 문자집합 |
| `Accept-Encoding` | 서버가 보내도 되는 인코딩 |
| `Accept-Language` | 서버가 보내도 되는 언어 |
| `TE (Transfer Encoding)` | 서버가 보내도 되는 확장 전송 코딩 |

**조건부 요청 헤더**

클라이언트는 서버에게 요청 후 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약이 있습니다.

| 헤더 | 설명 |
|---|:---:|
| `Expect` | 요청에 필요한 서버의 행동을 열거할 수 있게 해줌 |
| `If-Match` | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하는 경우에만 문서를 가져옴 |
| `If-Modified-Since` | 주어진 날짜 이후에 리소스가 변경되지 않았따면 요청을 제한 |
| `If-None-Match` | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하지 않는 경우에만 가져옴 |
| `If-Range` | 문서의 특정 범위에 대한 요청 |
| `If-Unmodified-Since` | 주어진 날짜 이후에 리소스가 변경되었다면 요청 제한 |
| `Range` | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청 |

**요청 보안 헤더**

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 가지고 있습니다.

| 헤더 | 설명 |
|---|:---:|
| `Authorization` | 클라이언트가 서버에게 제공하는 인증 그 자체를 담고 있음 |
| `Cookie` | 서버에게 토큰을 전달할 때 사용 |
| `Cookie2` | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용 |

**프락시 요청 헤더**

| 헤더 | 설명 |
|---|:---:|
| `Max-Forwards` | 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE 메서드와 사용 |
| `Proxy-Authorization` | Authorization과 같으나 프락시에서 인증을 할 때 쓰임 |
| `Proxy-Connection` | Connection과 같으나 프락시에서 연결을 맺을 때 쓰임 |

### 3.5.3 응답 헤더

- 클라이언트에게 정보를 제공하기 위한 헤더
- 예) ```Server: TIki-Hut/1.0``` Server 헤더는 클라이언트에게 그가 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 말해줍니다.

| 헤더 | 설명 |
|---|:---:|
| `Age` | 응답이 얼마나 되었는지 |
| `Public` | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 |
| `Retry-After` | 현재 리소스가 불가능한 상태일 때, 언제 가능한지 날짜 또는 시각 |
| `Server` | 서버 애플리케이션의 이름과 버전 |
| `TItle` | HTML 문서에서 주어진 것과 같은 제목 |
| `Warning` | 사유 구절에 있는 것보다 더 자세한 경고 메시지 |

**협상 헤더**

서버에 여러 언어로 번역된 HTML 문서가 있는 경우와 같이 여러가지 표현이 가능한 상황이라면, HTML/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인지 협상을 할 수 있습니다.

| 헤더 | 설명 |
|---|:---:|
| `Accept-Ranges` | 서버가 자원에 대해 받아들일 수 있는 범위의 형태 |
| `Vary` | 서버가 확인해 보아야 하고 응답에 영향을 줄 수 있는 헤더들의 목록 |

**응답 보안 헤더**

| 헤더 | 설명 |
|---|:---:|
| `Proxy-Authenticate` | 프락시에서 클라이언트로 보낸 인증요구의 목록 |
| `Set-Cookie` | 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용 |
| `Set-Cookie2` | RFC 2965로 정의된 쿠키 |
| `WWW-Authenticate` | 서버에서 클라이언트로 보낸 인증요구의 목록 |

### 3.5.4 엔티티 헤더

- 엔티티 헤더는 본문에 들어있는 데이터 타입이 무엇인지 말해줄 수 있습니다.
- 예) ```Content-Type: text/html; charset=iso-latin-1```

| 헤더 | 설명 |
|---|:---:|
| `Allow` | 엔티티에 대해 수행될 수 있는 요청 메서드들을 나열 |
| `Location` | 클라이언트에게 엔티티가 실제로 어디에 위치하고 있는지 말해줍니다. |

**콘텐츠 헤더**

콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용한 엔티티의 콘텐츠에 대한 구체적인 정보를 제공합니다.

| 헤더 | 설명 |
|---|:---:|
| `Content-Base` | 상대 URL을 확인하기 위한 Base URL |
| `Content-Encoding` | 본문에 적용된 인코딩 |
| `Content-Language` | 본문을 이해하는데 가장 적절한 자연어 |
| `Content-Length` | 본문의 길이나 크기 |
| `Content-Location` | 리소스의 실제 위치 |
| `Content-MD5` | 본문의 MD5 checksum |
| `Content-Range` | 엔티티가 해당하는 범위를 바이트 단위로 표현 |
| `Content-Type` | 본문의 객체 종류 |

**엔티티 캐싱 헤더**

리소스에 대한 캐시된 사본이 아직 유효한지에 대한 정보와, 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 잘 추정하기 위한 것처럼 엔티티 캐싱 헤더는 엔티티 캐싱에 대한 정보를 제공합니다.

| 헤더 | 설명 |
|---|:---:|
| `ETag` | 엔티티에 대한 태그 |
| `Expires` | 엔티티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| `Last-Modified` | 가장 최근 엔티티가 변경된 일시 |


### 3.5.5 확장 헤더

- 확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더입니다.

